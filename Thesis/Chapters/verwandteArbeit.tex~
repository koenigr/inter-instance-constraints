% Chapter Template

\chapter{Verwandte Arbeit} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Chapter 3. \emph{Verwandte Arbeit}} % Change X to a consecutive number; this is for the header on each page - perhaps a shortened title

%-----------------------------------
%	SECTION
%-----------------------------------
Dieses Kapitel soll sowohl einen Überblick über den aktuellen Forschungsstand zu Instanz-übergreifenden Regeln geben, als auch verschiedene Ansätze zur Implementierung von Compliance Checkern vorstellen.

\section{Untersuchung Instanz-übergreifender Regeln}
Bereits 1999 untersuchten Bertino et al. \cite{Bertino}, wie man Einschränkungen auf die Authorisierung von Nutzern und Rollen zu Aktivitäten in Geschäftsprozessen als Klauseln in einem logischen Programm darstellen kann. Die Klauseln, die vorgestellt werden, stellen keine End-User Sprache dar, sondern repräsentieren die Einschränkungen intern in einer Regeldatenbank. Der Körper einer Regel besteht dabei aus einer Konjunktion von logischen Literalen. Da ihr Ansatz die Authorisierung bei \textit{Workflow Management Systemen} (\textbf{WfMS}) erweitern soll, unterscheiden sie zwischen statischen und dynamischen Einschränkungen. Statische Einschränkungen können vor Beginn eines Arbeitsablaufs ausgewertet werden. Dynamische Regeln aktualisieren die Datenbank nach jedem Ausführen einer Aktivität.

2006 griffen Warner et al. \cite{warner_inter_instance} diesen Ansatz auf und erweiterten ihn um eine Notation, die Instanz-übergreifende Einschränkungen erlaubt, da sie erkennen, dass der vorherige Ansatz nicht ausreichend ist, um alle Betrugsmöglichkeiten abzudecken. Ebenso erlaubt die neu entwickelte Notation Einschränkungen zu definieren, die \textit{alle} bisherigen Instanzen in die Untersuchung mit einbeziehen, und somit nicht an ein Arbeitsablauf-Schema gebunden sind (\textit{Inter-Process}).

Diese Arbeit greift den Ansatz von \cite{warner_inter_instance} zur Darstellung als Klauseln in einem logischen Programm auf, um die Regeln und Logs in einer internen Wissensbasis zu repräsentieren. Um die Eingabe der Regeln für den Anwender möglichst intuitiv zu gestalten, wird dafür eine eigene Eingabesprache entwickelt. Im Unterschied zur Arbeit von \cite{warner_inter_instance} ist das Ziel dieser Arbeit die Untersuchung von Logs \textit{nach} Abschluss der Prozesse. Aus diesem Grund werden einige Prädikate und Regeln weggelassen, die bei \cite{warner_inter_instance} zur Berechnung während der Laufzeit notwendig sind. Zusätzlich werden arithmetische Operationen auf Variablen und Disjunktion erlaubt.

2012 stellen Leitner et al. in ihrer Arbeit \cite{instance_spanning} das "\textbf{I}dentification and \textbf{U}nification of \textbf{P}rocess \textbf{C}onstraints (\textbf{IUPC}) compliance Framework" vor, welches \textit{Intra-Instance}, \textit{Inter-Instance}, \textit{Inter-Process} und \textit{Inter-Organizational} Regeln bei Geschäftsprozessen erzwingt. \textit{Inter-Organizational} Regeln beziehen sich auf Prozesse, die von mehreren Organisationen ausgeführt werden. In dieser Arbeit wird dieser Fall nicht berücksichtigt, da die Logs nicht zwingend auf eine Organisation beschränkt sein müssen. Des weiteren basieren die Berechnung zur Einhaltung der Regeln in \cite{instance_spanning} auf \textit{Linear Time Logic} (\textbf{LTL}) und \textit{Compliance Rule Graphs}(\textbf{CRG}). Diese Abschlussarbeit arbeitet mit Fakten und Regeln in einem logischen Programm.


\section{SCIFF - SCIFFChecker - ProM}
\textbf{SCIFF} ist ein \textit{Framework} zur Überprüfung von  Logs bezüglich der Einhaltung von Regeln. Es basiert auf Forschungergebnissen des SOCS (\textbf{S}ocieties \textbf{O}f \textbf{C}omputee\textbf{S}) Projekts und wurde am \textbf{ENDIF} an der Universität Ferrara und am \textbf{DEIS} an der Universität Bologna entwickelt. \textit{SCIFF} bildet positive und negative Erwartungen aus einer Spezifikation auf logische Prädikate ab, um sie dann gegen eine konkrete Ausführung, die in Form von MXML Logs geliefert wird, zu testen. Diese \textit{Traces} werden dann als Regelkonform oder nicht Regelkonform bewertet. SCIFF läuft mit SICSTUS Prolog oder SWI-Prolog. Es wird auch als Plugin für das \textit{ProM Framework} in Form des SCIFFCheckers angeboten. Obwohl diese Arbeit hauptsächlich auf \cite{warner_inter_instance} basiert, weist sie viele Parallelen zu SCIFF auf. Jedoch untersucht SCIFF nur einzelne Instanzen von Prozessen. In dieser Arbeit wird ein Programm entwickelt, das die Untersuchung von Regeln zwischen mehreren Instanzen erlaubt. 
\cite{SCIFF} \cite{SCIFFPaper}\cite{SCIFF3}

\section{Weitere Ansätze}
Neben dem Einsatz von logischer Programmierung zur Auswertung von Logs in Bezug auf Einhaltung von Regeln gibt es weitere Ansätze, die hier kurz skizziert werden. Casati et al. stellen in ihrere Arbeit \cite{active_database} ein Framework vor, das aktive Datenbank Systeme ausnutzt, um Instanz-, Zeit- und Verlaufsabhängige Authorisierungsregeln aufzustellen. Die Regeln werden dabei als ECA (\textbf{E}vent - \textbf{C}ondition - \textbf{A}ction) Regeln aufgestellt. In \cite{rulelanguage} vergleicht Wagner neben weiteren Beschreibungssprachen wie \textit{UML}, \textit{OCL}, wie sich Prozessregeln in \textit{Prolog} und \textit{SQL} darstellen lassen. \textit{SQL} Regeln sind dabei sehr interessant, weil gleichzeitig eine SQL Datenbank dazu verwendet werden kann, um die Regeln auszuwerten.\\
Der LTLChecker ist ein weiteres Plugin für das \textit{ProM Framework} und verifiziert \textit{MXML} Logs  gegenüber einer Spezifikation mithilfe von \textit{LTL} (\textbf{L}inear \textbf{T}emporal \textbf{L}ogic).
\cite{LTLChecker}  

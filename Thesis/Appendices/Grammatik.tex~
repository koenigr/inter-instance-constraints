% Appendix D

\chapter{Grammatik} % Main appendix title

\label{Grammatik} % For referencing this appendix elsewhere, use \ref{AppendixA}

\lhead{Appendix R. \emph{Grammatik}} % This is for the header on each page - perhaps a shortened title


\begin{tabular}{lll}
$<$file$>$ 		&::=& ($<$define$>$)* ($<$explicitSetting$>$)* ($<$assignment$>$)*  $<$EOF$>$\\
$<$define$>$ 		&::=& $<$def-symbols$>$ $<$clause$>$ "(" $<$arg-type$>$ ("," $<$arg-type$>$ )* ")" \\
$<$explicitSetting$>$ 	&::=& $<$set-symbols$>$ $<$settableClauses$>$ ($<$konj$>$ $<$settableClauses$>$)* \\
$<$settableClauses$>$	&::=& $<$extern$>|<$specification$>|<$definedClause$>$ \\
$<$assignment$>$ 	&::=& $<$if$>$ $<$assignmentBody$>$ $<$then$>$ $<$assignmentHead$>$ \\
$<$description$>$ 	&::=& $<$desc$>$  $<$constant$>$ \\
$<$assignmentBody$>$  	&::=& ($<$neg$>$ )? $<$clauses$>$  ( $<$konj$>$  ($<$neg$>$ )? $<$clauses$>$ )* \\
$<$assignmentHead$>$ 	&::=& $<$enforcement$>|<$definedClause$>$\\
$<$clauses$>$ 		&::=& $<$atoms$>|$ "(" $<$atoms$>$  ($<$disj$>$  $<$atoms$>$ )* ")"\\
$<$atoms$>$ 		&::=& $<$specification$>$ 	\\	
			&&	$| <$status$>$ \\
			&&	$| <$comparison$>$ \\
			&&	$| <$conditional$>$ \\
			&&	$| <$extern$>$ \\
			&&	$| <$definedClause$>$ \\
$<$definedClause$>$ 	&::=& $<$clause$>$  "(" ($<$const$>|<$var$>$ ) ("," ($<$const$>|<$var$>$ ))* ")"\\
\hline
$<$var$>$ 		&::=& $<$uppercase letter$> | <$variable$> <$character$>$\\
$<$lowercase letter$>$  &::=& a $|$ b $|$ c $|$ ... $|$ x $|$ y $|$ z\\
$<$uppercase letter$>$  &::=& A $|$ B $|$ C $|$ ... $|$ X $|$ Y $|$ Z \\
$<$numeral$>$  		&::=& $<$digit$> | <$numeral$> <$digit$>$\\
$<$digit$>$  		&::=& 0 $|$ 1 $|$ 2 $|$ 3 $|$ 4 $|$ 5 $|$ 6 $|$ 7 $|$ 8 $|$ 9\\
$<$character$>$  	&::=& $<$lowercase letter$> | <$uppercase letter$> | <$digit$> | <$special$>$\\
$<$special$>$  		&::=& + $|$ - $|$ * $|$ / $|$ \ $| ^ | ~ | : |$ . $|$ ? $|$  $| # |$ \$ $|$ \&\\
$<$string$>$  		&::=& $<$character$> | <$string$> <$character$>$
\end{tabular}


\iffalse


					
/* Literals */
extern	: ut 'is related to' ut			#related
		| ut 'is partner of' ut			#partnerof
		| ut 'is in same group as' ut	#samegroup
		;
		
specification	: 'role' rt 'can execute' tt  		#roleTask // TODO bessere Bezeichnung
				| 'user' ut 'can execute' tt 		#userTask
				| 'user' ut 'belongs to role' rt 	#userRole
				|  rt 'is glb of' tt 				#glb
				|  rt 'is lub' tt 					#lub
				|  rt 'dominates' rt 				#dominate
				| 'critical_task_pair('tt','tt')'	#critTaskPair
				;

enforcement		: 'user'? ut 'cannot execute' tt	#cannotUser
				| 'role' r=rt 'cannot execute' tt	
				{System.out.println($r.text);}
				#cannotRole
				|  ut 'must execute' tt				#mustUser
				| 'mrole' rt 'must execute' tt 		#mustRole
				| 'panic'							#panic
				;
			
status			:  'user'? ut 'executed' tt			#executedUser
				|  'role' rt 'executed' tt			#executedRole
				|  ut 'is assigned to' tt			#assignedUser
				|  tt 'aborted'						#abortedTask // TODO hier auch mit den EventTypes..
				|  tt 'succeeded'					#succeededTask
				|  tt 'started'						#startedTask
				| 'EventType(' tt ').' (event | unknownEvent) #flexibleEvent
				|  ut 'is collaborator of' ut		#collaborator // TODO ??
				;
	
conditional		: 'NUMBER' WHERE conditionalBody 'IS' nt							#numSimple
				| 'NUMBER OF' VARIABLE WHERE conditionalBody 'IS' nt		#numVars
				| 'NUMBER OF DIFF' VARIABLE  WHERE conditionalBody 'IS' nt	#numDiff
				| 'SUM OF' VARIABLE  WHERE conditionalBody 'IS' nt			#sum
				| 'AVG OF' VARIABLE  WHERE conditionalBody 'IS' nt			#avg
				| 'MIN OF' VARIABLE WHERE conditionalBody 'IS' nt			#min
				| 'MAX OF' VARIABLE  WHERE conditionalBody 'IS' nt			#max
				;

conditionalBody 	: clauses ( KONJ clauses)* ;
	
comparison 		: equalityExpr	 					
				| inequalityExpr	
				; 
				
equalityExpr	: VARIABLE equality VARIABLE
				| nt equality nt
				| rt equality rt
				| tp equality tp
				| ts equality ts
				| wt equality wt // TODO wegmachen?
				| wi equality wi // TODO wegmachen?
				| ut equality ut
				;

inequalityExpr	: VARIABLE inequality VARIABLE
				| nt inequality nt
				| rt inequality rt
				| tp inequality tp
				| ts inequality ts
				;
				
	
event			: EVENTTYPE ; 


unknownEvent	: CONSTANT;

// Constants and Vars
ut				: CONSTANT | VARIABLE ;
rt				: CONSTANT | VARIABLE | ut ROLE | tt ROLE;
tt 				: intra { 
					if (context == Context.UNKNOWN) {
						context = Context.INTRA;
					} else if (context != Context.INTRA) {
					logger.log(Level.SEVERE, ""
						, new UnexpectedContextException($intra.text, "INTRA",  context.toString())
					);
					}
				}
				|inter { 
					if (context == Context.UNKNOWN) {
						context = Context.INTER;
					} else if (context != Context.INTER) {
					logger.log(Level.SEVERE, ""
						, new UnexpectedContextException($inter.text, "INTER",  context.toString())
					);
					}
				}
				|interp { 
					if (context == Context.UNKNOWN) {
						context = Context.INTERP;
					} else if (context != Context.INTERP) {
					logger.log(Level.SEVERE, ""
						, new UnexpectedContextException($interp.text, "INTERP", context.toString())
					);
					}
				}
				;

intra			: CONSTANT|VARIABLE 
				;
				
				
inter			: (CONSTANT|VARIABLE)'.'(CONSTANT|VARIABLE)
				;
				
				
interp			: (CONSTANT|VARIABLE)'.'(CONSTANT|VARIABLE)'.'(CONSTANT|VARIABLE)
				;
				
				
nt				: NUMBER 
				| VARIABLE 
				| '(' nt arithmetic nt ')'
				| 'Num_Var(' tt ').'CONSTANT
				;
				
st	    : 'String_Var(' tt ').'CONSTANT
		| VARIABLE
		; 
				
// timepoint symbols		
tp 		:DATETIME
		{ph.checkDateTime($DATETIME.text);}							# dateTime
		| DATE					
		{ph.checkDate($DATE.text);}									# date 	 
		| TIME		
		{ph.checkTime($TIME.text);}									# time
		| '(' tp ADD ts ')'    										# relativeTimepoint
		| tt  TIMESTAMP											# timestamp
		| VARIABLE 													# varTP
		; 
		
// timeinterval symbols
ts		: TIMEINTERVAL		
		{ph.checkTimeInterval($TIMEINTERVAL.text);}					# absoluteInterval
		| '(' tp SUB tp ')'											# timedifference
		| 'timeinterval(' tt ',' tt ')'								# timeinterval
		| VARIABLE													# varTS
		; 
	

// workflow symbols
wt		: tt WORKFLOW ; 

// workflow instances
wi 		: tt WORKFLOWINSTANCE;

		

// Comparison Cases
equality 	: EQUAL 		#equal
			| NOTEQUAL		#noteual
			;
inequality	: LOWER			#lower
			| LEQ			#leq
			| GREATER		#greater
			| GEQ			#geq
			;

arithmetic	: MUL 			#mul
			| DIV			#div
			| ADD			#add
			| SUB			#sub
			;

  MULTILINE_COMMENTS  : '/*' .*?  '*/' -> skip;
SINGLE_LINE_COMMENTS: '//' .*? '\n'    -> skip ;

// KEYWORDS
SET		: 'SET' | 'set'; // TODO hier auch Gro√ü und Kleinschreibung vermischt
IF		: 'IF' | 'if' | 'If' | 'iF';
THEN	: 'THEN';
NEG		: 'NOT'  | 'not';
KONJ 	: 'AND' | 'and'; // TODO
DISJ	: 'OR' | 'or'; // TODO
DEF		: ('DEF'|'DEFINE'|'define'|'def');   
DESC	: 'DESC' | 'desc' | 'description' ;
ARGS	: ('UT'|'RT'|'TT'|'WT'|'TauT'|'NT'| 'STRING_VAR');
WHERE	: 'WHERE';
ROLE	: '.Role';

TASKINSTANCE : '.InstanceID'; // TODO wegmachen?
WORKFLOWINSTANCE: .'WorkflowID'; // TODO wegmachen?
WORKFLOW:	'.Workflow'; // TODO wegmachen?


TIMESTAMP : '.Timestamp';

// SPECIAL SYMBOLS
EQUAL   	: '=' ;
NOTEQUAL	: '!=' ;
LOWER		: '<' ;
LEQ			: '<=' ;
GREATER		: '>' ;
GEQ			: '>=' ;
MUL		 	: '*' ;
DIV			: '/' ;
ADD			: '+' ;
SUB			: '-' ;


YEARS 	: NUMBER 'Y';
MONTHS	: NUMBER 'M';
DAYS	: NUMBER 'D';
HOURS	: NUMBER 'h';
MINUTES	: NUMBER 'm';
SECONDS	: NUMBER ('.' NUMBER)? 's';


TIMEINTERVAL: 'P' [ ]? YEARS [ ]? (MONTHS)? [ ]? (DAYS)? [ ]? (HOURS)? 
			[ ]? (MINUTES)? [ ]? (SECONDS)? 
			| 'P' [ ]? MONTHS [ ]? (DAYS)? [ ]? (HOURS)? 
			[ ]? (MINUTES)? [ ]? (SECONDS)? 
			| 'P' [ ]? DAYS [ ]? (HOURS)? 
			[ ]? (MINUTES)? [ ]? (SECONDS)? 
			| 'P' HOURS [ ]? (MINUTES)? [ ]? (SECONDS)? 
			| 'P' MINUTES [ ]? (SECONDS)? 
			| 'P' SECONDS
		 	; // TODO im Moment ist es so, dass es keine Variable mit P geben darf

DATETIME: NUMBER '-' NUMBER '-' NUMBER  'T' NUMBER (':' NUMBER (':' NUMBER ('.' NUMBER)?)? )? ;
DATE	: NUMBER '-' NUMBER ('-' NUMBER)? 	;
TIME	: NUMBER ':' NUMBER (':' NUMBER ('.' NUMBER)?)?  ;

// ELEMENTARY 
CONSTANT 	: '\''.*?'\'' {
	if(eventtypes.containsKey(getText())) {
		setType(eventtypes.get(getText()));
	}}
			|'"'.*?'"' {
	if(eventtypes.containsKey(getText())) {
		setType(eventtypes.get(getText()));
	}}
			;
VARIABLE : [A-Z][A-Za-z0-9]* ; 
CLAUSE	: [a-z_]+;
NUMBER : [0-9]+ ; // Null muss auch erlaubt sein
STRING  : [A-Za-z0-9]+; // Ist es schlimm, dass CLAUSE herausgefiltert wird?


// SKIP WHITESPACES
WS		: [ \t\r\n]+ -> skip;
\fi
  
